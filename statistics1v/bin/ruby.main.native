#!/usr/bin/ruby
#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# ruby.main - Objectives:
=begin
    1.  Provide ability to read and calculate columns from data inputfiles, most
    importantly, csv files, but perhaps also JSON files and CSV data from stdin.
    The file, or "stdin", would then be the first argument.
    2.  Provide default of native library, but option to use other parallel
    The parallel use would need to be a separate file handle, but would need to
    use virtually all the same code.  The technique will therefore be used,
    which should work across language environments, will be an exported
    environment variable assigned inside a shell alias version of the command,
    as with the following:
        $ alias ruby.main.versionx='export LibraryVersion=versionx;ruby.main'
    This will keep the modification from intruding needlessly into the code,
    though of course it still means compiles language versions will need to
    compile a different one for each library version, and in that case the
    binary would just be something like:
        rust.main.versionx
    3.  Provide the ability to call a single top-level object method on the
    results of the loaded data from the file specified.
    4.  Provide the ability to call a defined sequence of object methods on
    the results of the loaded data from the file specified.  This will be
    done with code in the sources for these bin programs, and it is presumed
    each such script will implement the same pattern.
    5.  It should not become more complicated than that.  These need to stay
    as simple demonstrations of function, and not applications for production
    use themselves.  To reiterate intentions stated elsewhere, the sames suite
    is intended to be:  1) and exercise for the author, 2) a learning tool to
    demonstrate to others how the same functin can be implemented across
    environments, and 3) an open source (GNU copyright) place to be able to
    pull demonstrated repeatability of function for use in other projects,
    when that might be helpful.
    6.  Also to repeat what I should have stated elsewhere:  Compliance with
    the GNU copyright is politely requested, but at the same time, I should
    not abuse or harass ANY non-corporate, non-wealthy user for copying any of
    these workings in a pinch for need or desperation or other exigency.
    Anyone doing such harassement so will not be supported by me actively.
    7.  Will provide a URL list csv caled:
        $SamesDs/statistics1v/extras/DataFileURLs.csv
    which will provide the URLs of known data files for use here that will
    then not need to be kept in GitHub but rather can be downloaded by users
    dynamically while using these scripts, each of which will then provide that
    function.
    8.  Note that ruby versions of all these will be the first, and
    prototyping versions of each of these sub-projects with all the vagaries
    that go along with that.  Still they should comply in quality with the
    rest of the suite.
=end

require 'getoptlong'

DataFormatFileExtension = "scdf" # For "Sames CSV Data Format"

$LibraryVersion='native'
if ENV.has_key?('LibraryVersion') and ENV['LibraryVersion'].size > 0 then
    $LibraryVersion = ENV['LibraryVersion']
end

SAMESHOME=File.expand_path("../..", __dir__)
SamesProjectDs=File.expand_path("..", __dir__)

SamesProjectLibraryInUse="#{SamesProjectDs}/SamesLib.#{$LibraryVersion}.rb"

require "#{SAMESHOME}/slib/SamesTopLib.rb"
require SamesProjectLibraryInUse

#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# Constant Identifiers

SamesClassColumnsDs = "#{SamesProjectDs}/classcolumns"

SegmentCountHistogramGeneration = 1
SegmentSizeHistogramGeneration = 2
SegmentSpecificationHistogramGeneration = 3

VoCHash = {
    'aad'               => 'generateAverageAbsoluteDeviation',
    'arithmeticmean'    => 'calculateArithmeticMean',
    'cov'               => 'generateCoefficientOfVariation',
    'csvlineOfx'        => 'transformToCSVLine',
    'excesskurtosis'    => 'requestExcessKurtosis',
    'geometricmean'     => 'calculateGeometricMean',
    'getx'              => 'getX',
    'harmonicmean'      => 'calculateHarmonicMean',
    'iseven?'           => 'isEvenN?',
    'jsonofx'           => 'transformToJSON',
    'histogram'         => '_generateHistogram',
    'kurtosis'          => 'requestKurtosis',
    'mad'               => 'generateMeanAbsoluteDifference',
    'max'               => 'getMax',
    'mean'              => 'calculateArithmeticMean',
    'median'            => 'requestMedian',
    'min'               => 'getMin',
    'mode'              => 'generateMode',
    'n'                 => 'getCount',
    'quartile'          => 'calculateQuartile',
    'quartileset'       => 'requestQuartileCollection',
    'range'             => 'requestRange',
    'sum'               => 'getSum',
    'resultsummary'     => '_requestResultSummary',
    'skewness'          => 'requestSkewness',
    'stddev'            => 'requestStandardDeviation',
    'variance'          => '_requestVariance',
}

ArgumentsVoC = {
    'aad'               => '<centerPoint>',
    'getx'              => '<indexOfX>',
    'histogram'         => '<HistogramType>',
    'quartile'          => '<indexOfQuartile>',
    'resultsummary'     => '<summaryOption>',
    'variance'          => '<varianceOption>',
}

VoDHash = {
    'binomialprobability'   => 'calculateBinomialProbability',
    'csvlineOfx'            => 'transformToCSVLine',
    'csvlistOfx'            => 'transformToCSVList',
    'jsonofx'               => 'transformToJSON',
    'frequencyTable'        => 'generateFrequencyTable',
    'getFrequency'          => 'getFrequency',
    'getx'                  => 'getX',
    'mode'                  => 'requestMode',
    'n'                     => 'getCount',
    'resultsummary'         => '_requestResultSummary'
}

ArgumentsVoD = {
    'binomialprobability'   => '<subjectValue> <nTrials> <nSuccesses>',
    'getFrequency'          => '',
    'getx'                  => '<indexOfX>',
    'resultsummary'         => '<summaryOption>'
}

#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# Lower Level Procedures

def _determineDataInputFile(fName)
    return fName    if File.exist?(fName)
    ds      = nil
    fn      = nil
    if fName =~ /^(.*)\/(.*)$/ then
        ds  = $1
        fn  = $2
    else
        ds  = SamesTmpData
        fn  = fName
    end
    fs = "#{ds}/#{fn}"
    return fs       if File.exist?(fs)
    fileurl = getKeptFileURL(fn)
    if assureInternetDataFileCopy(ds,fn,fileURL)
        raise ArgumentError, "File name '#{fName}' not procured."
    end
    return fs if File.exist?(fs)
    raise ArgumentError, "Downloaded File '#{fName}' still not there?  Programmer error?"
end

def _displayCommands(labelStr,cmdHash,cmdArguments)
    puts "\t#{labelStr} Commands:"
    cmdHash.keys.sort.each do |lkey|
        puts "\t\t#{lkey}(#{cmdArguments[lkey]})"   if cmdArguments.has_key?(lkey)
        puts "\t\t#{lkey}"                      unless cmdArguments.has_key?(lkey)
    end
end

def _generateHistogram(genType=SegmentCountHistogramGeneration,segmentSpecNo,startNumber)
    generateHistogramAAbyNumberOfSegments(desiredSegmentCount,startNumber=nil)
    generateHistogramAAbySegmentSize(segmentSize,startNumber=nil)
end

def _parseSamesLibVectorOfContinuousCommand(vocO,aList)
end

def _parseSamesLibVectorOfDiscreteCommand(vodO,aList)
end

def _readSamesLibStdIn
end

def _requestResultSummary
    requestResultAACSV
    requestResultCSVLine(includeHdr=false)
    requestResultJSON
    requestSummaryCollection
end

def _requestVariance
    requestVarianceSumOfDifferencesFromMean(populationCalculation=false)
    requestVarianceXsSquaredMethod(populationCalculation=false)
end

def _scanDataClasses(clArg)
    fn = clArg.sub(/.*\//,'')
    positedclassfspec = "#{SamesClassColumnsDs}/#{fn}.vc.csv"
    unless File.exist?(positedclassfspec)
        STDERR.puts <<-INSTRUCTIONS
        A column class file is required at #{positedclassfspec} to load the
        data.  You may use either of two formats:

        VectorOfContinuous,VectorOfDiscrete,..

        or

        C,D,...

        See examples in the #{SamesClassColumnsDs} folder.
        INSTRUCTIONS
        m="No column class input specification accompanies '#{clArg}'."
        raise ArgumentError, m
    end
    csvstr      = File.read( positedclassfspec )
    ba          = csvstr.split(',')
    vcarray     = nil
    if ba[0] == 'C' or ba[0] == 'D' then
        vcarray = VectorTable.arrayOfChar2VectorOfClasses(ba)
    else
        vcarray = VectorTable.arrayOfClassLabels2VectorOfClasses(ba)
    end
    return vcarray
end

#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# Top Level Procedures

def putsUsage
    puts <<-EOUsage
USAGE:  #{$0} <inputfile> [columns] [cmd] [cmd] [cmd]
    inputfile:  For now, a csv file, but with a corresponding class columns
    file in the folder #{SamesClassColumnsDs}, with one of two syntaxes,
    indicating the vector type to use for each column in its corresponding
    csv input file.
    columns:  one or more integer in a csv string with only commas; no spaces.
    cmds:  a list of commands with a parentheses surrounded list of arguments
    when they are required.  Commands are in two groups:  Continuous, and
    Discrete.
    
    EOUsage
    _displayCommands("Continuous",VoCHash,ArgumentsVoC)
    _displayCommands("Discrete",VoDHash,ArgumentsVoD)
end

def loadDataFile(clArg)
STDERR.puts "trace 0 clArg:  #{clArg}"
    fspec = _determineDataInputFile(clArg)
STDERR.puts "trace 1 fspec:  #{fspec}"
    vcarray = _scanDataClasses(fspec)
STDERR.puts "trace 2 vcarray:  #{vcarray.size}"
    if fspec =~ /.csv$/ then
        localo = VectorTable.newFromCSV(vcarray,fspec)
        return localo
    else
        m = "This file type (#{fSpec}) is not presently supported."
        raise ArgumentError, m
    end
end

def parseCommands(cvO,cmdArray)
    cmdArray.each do |lcmd|
        result = cvO.send(VoCHash[lcmd])
        puts "#{lcmd}:  #{result}"
    end
end

def scanColumnsSpecification(columnSet,tovO)
    ca = nil
    if columnSet.is_a? Integer
        ca = [columnSet]
    elsif      isANumStr?(columnSet) then
        ca = [columnSet.to_i]
    elsif columnSet.is_a? String and columnSet =~ /\d,\d/
        ca = columnSet.split(',').map(&:to_i)
    end
    return ca
end

#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# Init

if ARGV.size == 0
    STDERR.puts "Usage Error."
    putsUsage
    exit 1
end

#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# Main

tovo    = loadDataFile(ARGV[0])
if ARGV.size > 1 then
    columns = scanColumnsSpecification(ARGV[1],tovo)
    cmds    = ARGV.drop(2)
    columns.each do |lcolumn|
        lcv = tovo.getVectorObject(lcolumn)
        parseCommands(lcv,cmds)
    end
else
    puts "Columns are as follows:"
    i = 0
    tovo.eachColumnVector do |lcv|
        n = lcv.getCount
        puts "Column[#{i}]:  #{lcv.class}, size:  #{n}."
        i += 1
    end
end

#2345678901234567890123456789012345678901234567890123456789012345678901234567890
# End of ruby.main
