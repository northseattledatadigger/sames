#[derive(Error, Debug)]
pub enum DataStoreError {
    #[error("data store disconnected")]
    Disconnect(#[from] io::Error),
    #[error("the data for key `{0}` is not available")]
    Redaction(String),
    #[error("invalid header (expected {expected:?}, found {found:?})")]
    InvalidHeader {
        expected: String,
        found: String,
    },
    #[error("unknown data store error")]
    Unknown,
}
 */

// This is partly stolen from:  https://kerkour.com/rust-error-handling
// Also:  https://crates.io/crates/thiserror

/*
pub enum ProcessingError {
    #[error(transparent)]
    FailedToOpenFile(#[from] anyhow::Error),
    #[error(transparent)]
    FailedToReadFile(#[from] anyhow::Error),
    #[error(transparent)]
    FailedToParseString(#[from] anyhow::Error),
}
 */

                //m = "Range [{startNo},{stopNo}] overlaps with another range:";
                //m +="  [{lroo.start_no},{lroo.stop_no}].";
                //eprintln!(m);

pub enum ValidationError {
    #[error("String number {0} exceeds float capacity")]
    FloatCapacityExceeded(String),
    #[error("Value Range Conflict {0} out of range [{1},{2}]")]
    ValueRangeConflict(f64,f64,f64,f64),
    #[error("Invalid argument: {0}")]
    InvalidArgument(String),
    #[error("No range found for value: '{0}'")]
    NoRangeFoundForValue(f64),
    #[error("Value {0} below low limit {1}")]
    ValueBelowLowLimit(f64,f64),
    #[error("Value {0} at or above high stop point {1}")]
    ValueAtOrAboveHighStop(f64,f64),
}

class HistogramOfX:

    def __init__(self,lowestValue,highestValue):
        if ( not isinstance(lowestValue,numbers.Number) ):
            raise ValueError(f"lowestValue argument '{lowestValue}' is not a number.")
        if ( not isinstance(highestValue,numbers.Number) ):
            raise ValueError(f"highestValue argument '{highestValue}' is not a number.")
        self.FrequencyAA    = {}
        self.Max            = highestValue
        self.Min            = lowestValue

    def _validateNoOverlap(self,startNo,stopNo):
        if ( not isinstance(startNo,numbers.Number) ):
            raise ValueError(f"startNo argument '{startNo}' is not a number.")
        if ( not isinstance(stopNo,numbers.Number) ):
            raise ValueError(f"stopNo argument '{stopNo}' is not a number.")
        for lroo in self.FrequencyAA.values():
            if lroo.hasOverlap(startNo,stopNo):
                m = f"Range [{startNo},{stopNo}] overlaps with another range:  [{lroo.StartNo},{lroo.StopNo}]."
                raise ValueError(m)

    def addToCounts(self,xFloat):
        if ( not isinstance(xFloat,numbers.Number) ):
            raise ValueError(f"xFloat argument '{xFloat}' is not a number.")
        for lstartno in sorted(self.FrequencyAA):
            lroo = self.FrequencyAA[lstartno]
            if xFloat < lroo.StopNo:
                lroo.addToCount()
                return
        m = "Programmer Error:  "
        m += f"No Frequency range found for xFloat:  '{xFloat}'."
        raise ValueError( m )

    def generateCountCollection(self):
        orderedlist = []
        for lstartno in sorted(self.FrequencyAA):
            lroo = self.FrequencyAA[lstartno]
            orderedlist.append([lstartno,lroo.StopNo,lroo.Count])
        return orderedlist

    @classmethod
    def newFromDesiredSegmentCount(cls,startNo,maxNo,desiredSegmentCount,extraMargin=None):
        if extraMargin is None:
            extraMargin = 0
        if ( not isinstance(startNo,numbers.Number) ):
            raise ValueError(f"startNo argument '{startNo}' is not a number.")
        if ( not isinstance(maxNo,numbers.Number) ):
            raise ValueError(f"maxNo argument '{maxNo}' is not a number.")
        if ( type(desiredSegmentCount) != int ):
            raise ValueError(f"desiredSegmentCount argument '{desiredSegmentCount}' is not an integer.")
        if ( not isinstance(extraMargin,numbers.Number) ):
            raise ValueError(f"extraMargin argument '{extraMargin}' is not a number.")
        # xc 20231106:  Don't worry about cost of passing the AA around until efficiency passes later.
        totalbreadth    = float( maxNo - startNo + 1 + extraMargin )
        dscf            = float(desiredSegmentCount)
        segmentsize     = totalbreadth / dscf
        localo          = cls.newFromUniformSegmentSize(startNo,maxNo,segmentsize)
        return localo

    @classmethod
    def newFromUniformSegmentSize(cls,startNo,maxNo,segmentSize):
        if ( not isinstance(startNo,numbers.Number) ):
            raise ValueError(f"startNo argument '{startNo}' is not a number.")
        if ( not isinstance(maxNo,numbers.Number) ):
            raise ValueError(f"maxNo argument '{maxNo}' is not a number.")
        if ( not isinstance(segmentSize,numbers.Number) ):
            raise ValueError(f"segmentSize argument '{segmentSize}' is not a number.")
        # xc 20231106:  Don't worry about cost of passing the AA around until efficiency passes later.
        localo          = HistogramOfX(startNo,maxNo)
        bottomno        = startNo
        topno           = bottomno + segmentSize
        while bottomno <= maxNo:
            localo.setOccurrenceRange(bottomno,topno)
            bottomno    = topno
            topno       += segmentSize
        return localo

    def setOccurrenceRange(self,startNo,stopNo):
        if ( not isinstance(startNo,numbers.Number) ):
            raise ValueError(f"startNo argument '{startNo}' is not a number.")
        if ( not isinstance(stopNo,numbers.Number) ):
            raise ValueError(f"stopNo argument '{stopNo}' is not a number.")
        if stopNo <= startNo:
            raise ValueError(f"stopNo must be larger than startNo.")
        self._validateNoOverlap(startNo,stopNo)
        self.FrequencyAA[startNo] = RangeOccurrence(startNo,stopNo)

    fn validateRangesComplete(&self) -> Result<(), ValidationError> {
        i = 0
        lroo = None
        previous_lroo = None
        for lstartno in sorted(self.FrequencyAA):
            lroo = self.FrequencyAA[lstartno]
            if lstartno != lroo.StartNo:
                raise IndexError( "Programmer Error on startno assignments." )
            if i == 0:
                if lroo.StartNo > self.Min:# NOTE:  Start may be before the minimum,
                                           # but NOT after it, as minimum value must
                                           # be included in the first segment.
                    m = f"Range [{lroo.StartNo},{lroo.StopNo}] "
                    m += f" starts after the minimum designated value '{self.Min}."
                    raise IndexError( m )
            else:
                if lroo.StartNo != previous_lroo.StopNo:
                    m = f"Range [{previous_lroo.StartNo},{previous_lroo.StopNo}]"
                    m += " is not adjacent to the next range "
                    m += f"[{lroo.StartNo},{lroo.StopNo}]."
                    raise IndexError( m )
            i += 1
            previous_lroo = lroo

        if self.Max > lroo.StopNo:
            m = f"Range [{lroo.StartNo},{lroo.StopNo}] "
            m += f" ends before the maximum value '{self.Max}."
            raise IndexError( m )


